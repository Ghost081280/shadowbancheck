<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowBanCheck - Real Agent Test</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #0a0a0a; color: #e0e0e0; }
        h1 { color: #ff6b35; }
        h2 { color: #ffa500; border-bottom: 1px solid #333; padding-bottom: 10px; margin-top: 30px; }
        h3 { color: #60a5fa; }
        .test-section { background: #1a1a1a; border-radius: 8px; padding: 20px; margin: 20px 0; }
        .pass { color: #4ade80; }
        .fail { color: #f87171; }
        .info { color: #60a5fa; }
        .warn { color: #fbbf24; }
        pre { background: #0d0d0d; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 11px; max-height: 300px; }
        button { background: #ff6b35; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 16px; margin: 5px; }
        button:hover { background: #ff8c5a; }
        input, textarea { background: #0d0d0d; border: 1px solid #333; color: #e0e0e0; padding: 10px; border-radius: 4px; width: 100%; margin: 10px 0; box-sizing: border-box; }
        textarea { height: 100px; font-family: monospace; }
        .agent-status { display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; }
        .agent-card { background: #252525; padding: 12px 15px; border-radius: 6px; min-width: 180px; }
        .agent-card.loaded { border-left: 3px solid #4ade80; }
        .agent-card.missing { border-left: 3px solid #f87171; }
        .score-display { font-size: 48px; font-weight: bold; text-align: center; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .score-low { background: linear-gradient(135deg, #166534, #15803d); }
        .score-medium { background: linear-gradient(135deg, #ca8a04, #a16207); }
        .score-high { background: linear-gradient(135deg, #dc2626, #b91c1c); }
        .signal-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin: 15px 0; }
        .signal-card { background: #252525; padding: 15px; border-radius: 6px; }
        .signal-card h4 { margin: 0 0 10px 0; color: #ffa500; }
        .three-point { display: flex; gap: 10px; font-size: 11px; margin-top: 10px; }
        .three-point > div { flex: 1; background: #1a1a1a; padding: 8px; border-radius: 4px; }
        .three-point .label { color: #888; font-size: 10px; }
        .findings-list { list-style: none; padding: 0; margin: 10px 0; }
        .findings-list li { padding: 8px 12px; margin: 5px 0; border-radius: 4px; font-size: 13px; }
        .findings-list .critical { background: rgba(220, 38, 38, 0.3); border-left: 3px solid #dc2626; }
        .findings-list .high { background: rgba(249, 115, 22, 0.2); border-left: 3px solid #f97316; }
        .findings-list .medium { background: rgba(251, 191, 36, 0.2); border-left: 3px solid #fbbf24; }
        .findings-list .low { background: rgba(96, 165, 250, 0.2); border-left: 3px solid #60a5fa; }
        .findings-list .none { background: rgba(74, 222, 128, 0.2); border-left: 3px solid #4ade80; }
        select { padding: 10px; background: #0d0d0d; color: #e0e0e0; border: 1px solid #333; border-radius: 4px; margin-right: 10px; }
    </style>
</head>
<body>
    <h1>üî• ShadowBanCheck - Real 5-Factor Engine Test</h1>
    <p>Testing with your actual agent code - all 5 factors with 3-Point Intelligence</p>
    
    <div class="test-section">
        <h2>üìä Agent Registry Status</h2>
        <div id="agent-status" class="agent-status">Loading agents...</div>
    </div>
    
    <div class="test-section">
        <h2>üîç Live Content Analysis</h2>
        <textarea id="test-content" placeholder="Enter content to analyze...">Check out my crypto gains! üöÄüåôüíé #followback #crypto #investing 

Get FREE tokens! Click here: https://bit.ly/scamlink 

Follow @elonmusk for more alpha! DM for giveaway winners!</textarea>
        <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
            <select id="platform-select">
                <option value="twitter">Twitter/X</option>
                <option value="reddit">Reddit</option>
                <option value="instagram">Instagram</option>
                <option value="tiktok">TikTok</option>
            </select>
            <button onclick="runFullAnalysis()">üîç Run 5-Factor Analysis</button>
            <button onclick="runDetectionOnly()" style="background:#4a5568;">Test Detection Agent Only</button>
        </div>
        <div id="main-result"></div>
    </div>
    
    <div class="test-section">
        <h2>üì° Signal Analysis (Factor 4 - Detection Agent)</h2>
        <div id="signal-results" class="signal-grid"></div>
    </div>
    
    <div class="test-section">
        <h2>ü§ñ All Agent Results</h2>
        <div id="all-agents"></div>
    </div>
    
    <div class="test-section">
        <h2>üìã Raw Output</h2>
        <pre id="raw-output">Run an analysis to see raw output...</pre>
    </div>

<!-- ============================================================================
     AGENT-BASE.JS (from user's actual file)
     ============================================================================ -->
<script>
(function() {
'use strict';

class AgentBase {
    constructor(agentId, factorNumber, weight) {
        this.agentId = agentId;
        this.factorNumber = factorNumber;
        this.weight = weight;
        this.enabled = true;
        this.useDemo = true;
    }
    
    async analyze(input) {
        return { agentId: this.agentId, factorNumber: this.factorNumber, score: 0, confidence: 0, findings: [], message: 'Not implemented' };
    }
    
    async analyzeAccount(username, platform) { return this.analyze({ type: 'account', username, platform }); }
    async analyzePost(postId, platform, postData = null) { return this.analyze({ type: 'post', postId, platform, postData }); }
    async analyzeText(text, platform) { return this.analyze({ type: 'text', text, platform }); }
    
    getWeightedScore(rawScore) { return (rawScore * this.weight) / 100; }
    normalizeScore(score, max) { return max === 0 ? 0 : Math.min(100, Math.max(0, (score / max) * 100)); }
    
    calculateConfidence(data, requiredFields) {
        if (!data || !requiredFields || requiredFields.length === 0) return 0;
        let available = 0;
        for (const field of requiredFields) {
            if (data[field] !== undefined && data[field] !== null) available++;
        }
        return Math.round((available / requiredFields.length) * 100);
    }
    
    createResult(options = {}) {
        return {
            agentId: this.agentId,
            agent: this.getFactorName(),
            factorNumber: this.factorNumber,
            factorName: this.getFactorName(),
            weight: this.weight,
            enabled: this.enabled,
            demo: this.useDemo,
            rawScore: options.rawScore || 0,
            weightedScore: this.getWeightedScore(options.rawScore || 0),
            confidence: options.confidence || 0,
            findings: options.findings || [],
            flags: options.flags || [],
            warnings: options.warnings || [],
            timestamp: new Date().toISOString(),
            processingTime: options.processingTime || 0,
            dataSource: this.useDemo ? 'demo' : 'live',
            message: options.message || null
        };
    }
    
    createFinding(type, message, impact = 0, details = {}) {
        return { type, message, impact, severity: this.getSeverity(impact), details, agent: this.agentId, factor: this.factorNumber };
    }
    
    getSeverity(impact) {
        if (impact >= 75) return 'critical';
        if (impact >= 50) return 'high';
        if (impact >= 25) return 'medium';
        if (impact > 0) return 'low';
        return 'none';
    }
    
    getFactorName() {
        const names = { 1: 'Platform API Analysis', 2: 'Web/Search Analysis', 3: 'Historical Data', 4: 'Real-Time Detection', 5: 'Predictive Intelligence' };
        return names[this.factorNumber] || `Factor ${this.factorNumber}`;
    }
    
    isEnabled() { return this.enabled; }
    setEnabled(enabled) { this.enabled = !!enabled; }
    setDemoMode(useDemo) { this.useDemo = !!useDemo; }
    log(message, level = 'info') { console[level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log'](`[${this.agentId}]`, message); }
    getInfo() { return { agentId: this.agentId, factorNumber: this.factorNumber, factorName: this.getFactorName(), weight: this.weight, enabled: this.enabled, useDemo: this.useDemo }; }
}

const AgentRegistry = {
    agents: {},
    register(agent) { if (agent?.agentId) this.agents[agent.agentId] = agent; },
    get(agentId) { return this.agents[agentId] || null; },
    getByFactor(factorNumber) { for (const agent of Object.values(this.agents)) { if (agent.factorNumber === factorNumber) return agent; } return null; },
    getAll() { return { ...this.agents }; },
    getEnabled() { return Object.values(this.agents).filter(a => a.isEnabled()); },
    async runAll(input) {
        const results = [];
        for (const agent of this.getEnabled()) {
            try { results.push(await agent.analyze(input)); }
            catch (error) { results.push({ agentId: agent.agentId, factorNumber: agent.factorNumber, error: error.message, rawScore: 0, confidence: 0 }); }
        }
        return results.sort((a, b) => a.factorNumber - b.factorNumber);
    },
    hasAllFactors() { return new Set(Object.values(this.agents).map(a => a.factorNumber)).size === 5; },
    getTotalWeight() { return Object.values(this.agents).reduce((sum, a) => sum + a.weight, 0); }
};

window.AgentBase = AgentBase;
window.AgentRegistry = AgentRegistry;
console.log('‚úÖ AgentBase loaded');
})();
</script>

<!-- ============================================================================
     AGENT-PLATFORM-API.JS - Factor 1 (20%) - Real-Time API checks
     ============================================================================ -->
<script>
(function() {
'use strict';

class PlatformAPIAgent extends window.AgentBase {
    constructor() {
        super('platform-api', 1, 20);
        this.cache = new Map();
        this.cacheTimeout = 30000;
    }
    
    async analyze(input) {
        const startTime = Date.now();
        const findings = [];
        let rawScore = 0;
        
        if (input.type === 'text') {
            // For text analysis, we check visibility of extracted elements
            findings.push(this.createFinding('api_text_check', 'Text content analyzed for API-level flags', 0));
            
            // Demo: slight variation
            if (this.useDemo && Math.random() > 0.7) {
                rawScore = 15;
                findings.push(this.createFinding('api_minor_flag', 'Minor API-level flag detected', 15));
            }
        }
        
        return this.createResult({ rawScore, confidence: 85, findings, processingTime: Date.now() - startTime });
    }
    
    // 3-Point Intelligence: Real-Time hashtag visibility
    async checkHashtagVisibility(hashtags, platformId) {
        if (!hashtags || hashtags.length === 0) return { available: false, riskScore: 0 };
        
        const results = { available: true, visibility: 'unknown', blocked: [], visible: [], restricted: [], riskScore: 0 };
        
        // Known blocked hashtags per platform
        const blockedTags = {
            twitter: ['#followback', '#follow4follow', '#f4f', '#l4l', '#teamfollowback', '#gainwithxtina', '#500aday'],
            instagram: ['#followback', '#like4like', '#l4l', '#followforfollow', '#instasex', '#adulting'],
            tiktok: ['#fyp', '#foryoupage'] // These reduce reach, not blocked
        };
        
        const platformBlocked = blockedTags[platformId] || blockedTags.twitter;
        
        for (const tag of hashtags) {
            const normalizedTag = tag.toLowerCase();
            if (platformBlocked.includes(normalizedTag)) {
                results.blocked.push({ tag, status: 'blocked', reason: 'Known engagement manipulation hashtag' });
                results.riskScore += 30;
            } else {
                results.visible.push({ tag, status: 'visible' });
            }
        }
        
        results.visibility = results.blocked.length > 0 ? 'partially_blocked' : 'visible';
        results.riskScore = Math.min(100, results.riskScore);
        return results;
    }
    
    // 3-Point Intelligence: Real-Time link visibility
    async checkLinkVisibility(urls, platformId) {
        if (!urls || urls.length === 0) return { available: false, riskScore: 0 };
        
        const results = { available: true, blocked: [], warned: [], visible: [], riskScore: 0 };
        
        // Known throttled/blocked domains
        const throttledDomains = {
            twitter: ['facebook.com', 'instagram.com', 'threads.net', 'bsky.app', 'substack.com'],
            instagram: ['tiktok.com', 'twitter.com', 'x.com', 'youtube.com'],
            tiktok: ['youtube.com', 'instagram.com']
        };
        
        const shorteners = ['bit.ly', 'tinyurl.com', 't.co', 'goo.gl', 'ow.ly', 'buff.ly', 'rebrand.ly'];
        
        for (const url of urls) {
            const domain = this.extractDomain(url);
            const platformThrottled = throttledDomains[platformId] || [];
            
            if (shorteners.some(s => domain.includes(s))) {
                results.warned.push({ url, domain, reason: 'Link shortener reduces trust/reach' });
                results.riskScore += 20;
            } else if (platformThrottled.some(d => domain.includes(d))) {
                results.warned.push({ url, domain, reason: 'Competitor domain - may be throttled', delay: 2544 });
                results.riskScore += 25;
            } else {
                results.visible.push({ url, domain });
            }
        }
        
        results.riskScore = Math.min(100, results.riskScore);
        return results;
    }
    
    // 3-Point Intelligence: Real-Time account status
    async checkAccountStatus(usernames, platformId) {
        if (!usernames || usernames.length === 0) return { available: false, riskScore: 0 };
        
        const results = { available: true, suspended: [], shadowbanned: [], restricted: [], active: [], notFound: [], riskScore: 0 };
        
        for (const username of usernames.slice(0, 5)) {
            const normalizedUser = username.replace(/^@/, '').toLowerCase();
            
            // Demo: simulate status checks
            const rand = Math.random();
            if (rand < 0.05) {
                results.suspended.push({ username: normalizedUser, reason: 'Account suspended' });
                results.riskScore += 25;
            } else if (rand < 0.1) {
                results.notFound.push({ username: normalizedUser, reason: 'Account not found' });
                results.riskScore += 10;
            } else {
                results.active.push({ username: normalizedUser });
            }
        }
        
        results.riskScore = Math.min(100, results.riskScore);
        return results;
    }
    
    extractDomain(url) {
        try {
            const urlObj = new URL(url);
            return urlObj.hostname.replace('www.', '');
        } catch (e) {
            const match = url.match(/(?:https?:\/\/)?(?:www\.)?([^\/\?]+)/i);
            return match ? match[1] : url;
        }
    }
}

const agent = new PlatformAPIAgent();
window.AgentRegistry.register(agent);
window.PlatformAPIAgent = agent;
console.log('‚úÖ PlatformAPIAgent (Factor 1) loaded');
})();
</script>

<!-- ============================================================================
     AGENT-WEB-ANALYSIS.JS - Factor 2 (20%) - Predictive web searches
     ============================================================================ -->
<script>
(function() {
'use strict';

class WebAnalysisAgent extends window.AgentBase {
    constructor() {
        super('web-analysis', 2, 20);
        this.cache = new Map();
        this.cacheTimeout = 300000;
    }
    
    async analyze(input) {
        const startTime = Date.now();
        const findings = [];
        let rawScore = 0;
        
        // Simulate web visibility checks
        const searchVisible = Math.random() > 0.25;
        if (!searchVisible) {
            findings.push(this.createFinding('search_ban', 'Content may not appear in search results (logged out)', 50, { context: 'External search check' }));
            rawScore += 35;
        } else {
            findings.push(this.createFinding('search_visible', 'Content appearing in search results', 0));
        }
        
        const repliesVisible = Math.random() > 0.2;
        if (!repliesVisible) {
            findings.push(this.createFinding('reply_deboosting', 'Replies may be hidden under "Show more"', 35));
            rawScore += 20;
        }
        
        return this.createResult({ rawScore: Math.min(100, rawScore), confidence: 70, findings, processingTime: Date.now() - startTime });
    }
    
    // 3-Point Intelligence: Predictive web searches
    async searchForFlaggedContent(queries, platformId) {
        if (!queries || queries.length === 0) return { available: false, riskScore: 0 };
        
        const results = { available: true, riskScore: 0, sources: [], articles: [], searchQueries: queries, recentMentions: 0, sentiment: 'neutral' };
        
        for (const query of queries.slice(0, 3)) {
            const searchTerms = query.toLowerCase();
            
            // Simulate Reddit search
            if (searchTerms.includes('banned') || searchTerms.includes('shadowban')) {
                results.sources.push('reddit');
                results.recentMentions += Math.floor(Math.random() * 15) + 5;
                results.riskScore += 20;
                results.sentiment = 'negative';
                results.articles.push({ source: 'reddit', title: `Discussion: ${query}`, subreddit: 'Twitter', sentiment: 'negative' });
            }
            
            // Simulate news search
            if (searchTerms.includes('banned') || searchTerms.includes('removed')) {
                if (Math.random() > 0.5) {
                    results.sources.push('news');
                    results.riskScore += 15;
                    results.articles.push({ source: 'news', title: `${platformId} policy update`, relevance: 'medium' });
                }
            }
        }
        
        results.riskScore = Math.min(100, results.riskScore);
        results.confidence = 30 + results.sources.length * 15 + Math.min(20, results.recentMentions);
        return results;
    }
}

const agent = new WebAnalysisAgent();
window.AgentRegistry.register(agent);
window.WebAnalysisAgent = agent;
console.log('‚úÖ WebAnalysisAgent (Factor 2) loaded');
})();
</script>

<!-- ============================================================================
     AGENT-HISTORICAL.JS - Factor 3 (15%) - Historical data
     ============================================================================ -->
<script>
(function() {
'use strict';

class HistoricalAgent extends window.AgentBase {
    constructor() {
        super('historical', 3, 15);
        this.historyStore = new Map();
        this.itemScoreStore = new Map();
    }
    
    async analyze(input) {
        const startTime = Date.now();
        const findings = [];
        let rawScore = 0;
        
        // Simulate historical analysis
        const hasHistory = Math.random() > 0.4;
        
        if (!hasHistory) {
            findings.push(this.createFinding('no_history', 'No previous checks found for this content', 0, { note: 'First time analysis' }));
            return this.createResult({ rawScore: 0, confidence: 30, findings, processingTime: Date.now() - startTime, message: 'No historical data' });
        }
        
        const trend = Math.random();
        if (trend > 0.7) {
            findings.push(this.createFinding('worsening_trend', 'Historical trend shows increasing restriction probability', 25));
            rawScore += 20;
        } else if (trend < 0.3) {
            findings.push(this.createFinding('improving_trend', 'Historical trend shows improving visibility', -10));
        } else {
            findings.push(this.createFinding('stable_trend', 'Historical data shows stable patterns', 0));
        }
        
        const avgScore = Math.floor(Math.random() * 40) + 10;
        findings.push(this.createFinding('historical_average', `Average score from previous checks: ${avgScore}%`, 0, { averageScore: avgScore }));
        
        return this.createResult({ rawScore: Math.min(100, rawScore), confidence: 65, findings, processingTime: Date.now() - startTime });
    }
    
    // 3-Point Intelligence: Get past scores for items
    async getPastScores(items, type, platformId) {
        if (!items || items.length === 0) return { available: false, scores: [], averageScore: 0 };
        
        const results = { available: true, scores: [], trends: [], averageScore: 0, trendDirection: 'stable', itemsWithHistory: 0, itemsWithoutHistory: 0 };
        
        let totalScore = 0;
        let scoreCount = 0;
        
        for (const item of items) {
            const hasHistory = Math.random() > 0.5;
            
            if (hasHistory) {
                results.itemsWithHistory++;
                const score = Math.floor(Math.random() * 50) + 10;
                totalScore += score;
                scoreCount++;
                
                results.scores.push({ item, currentScore: score, checkCount: Math.floor(Math.random() * 5) + 1, trend: Math.random() > 0.7 ? 'worsening' : 'stable' });
            } else {
                results.itemsWithoutHistory++;
                results.scores.push({ item, currentScore: null, checkCount: 0, trend: 'unknown' });
            }
        }
        
        results.averageScore = scoreCount > 0 ? Math.round(totalScore / scoreCount) : 0;
        results.trendDirection = Math.random() > 0.7 ? 'worsening' : 'stable';
        results.available = results.itemsWithHistory > 0;
        
        return results;
    }
    
    storeItemScore(item, type, platformId, score) {
        const key = `${type}:${platformId}:${item.toLowerCase()}`;
        let history = this.itemScoreStore.get(key) || [];
        history.push({ score, timestamp: new Date().toISOString() });
        if (history.length > 20) history = history.slice(-20);
        this.itemScoreStore.set(key, history);
    }
}

const agent = new HistoricalAgent();
window.AgentRegistry.register(agent);
window.HistoricalAgent = agent;
console.log('‚úÖ HistoricalAgent (Factor 3) loaded');
})();
</script>

<!-- ============================================================================
     AGENT-DETECTION.JS - Factor 4 (25%) - Core signal detection with 3-Point
     ============================================================================ -->
<script>
(function() {
'use strict';

const PLATFORM_MODULES = {
    twitter: { total: 21, hashtags: 4, cashtags: 3, links: 4, content: 4, mentions: 3, emojis: 3 },
    reddit: { total: 14, hashtags: 0, cashtags: 0, links: 4, content: 4, mentions: 3, emojis: 3 },
    instagram: { total: 18, hashtags: 4, cashtags: 0, links: 4, content: 4, mentions: 3, emojis: 3 },
    tiktok: { total: 21, hashtags: 4, cashtags: 3, links: 4, content: 4, mentions: 3, emojis: 3 },
    facebook: { total: 18, hashtags: 3, cashtags: 0, links: 4, content: 4, mentions: 3, emojis: 4 },
    youtube: { total: 14, hashtags: 3, cashtags: 0, links: 3, content: 4, mentions: 2, emojis: 2 },
    linkedin: { total: 17, hashtags: 4, cashtags: 0, links: 4, content: 4, mentions: 3, emojis: 2 }
};

class DetectionAgent extends window.AgentBase {
    constructor() {
        super('detection', 4, 25);
        this.currentPlatform = 'twitter';
    }
    
    async analyze(input) {
        const startTime = Date.now();
        const platform = input.platform || 'twitter';
        this.currentPlatform = platform;
        const platformModules = PLATFORM_MODULES[platform] || PLATFORM_MODULES.twitter;
        const text = input.text || input.postData?.text || input.postData?.tweetText || '';
        
        if (!text) {
            return this.createResult({ rawScore: 0, confidence: 100, findings: [this.createFinding('no_content', 'No content to analyze', 0)], processingTime: Date.now() - startTime });
        }
        
        // Analyze all 6 signals with 3-Point Intelligence
        const signals = {
            hashtags: await this.analyzeHashtags(text, platform, platformModules),
            cashtags: await this.analyzeCashtags(text, platform, platformModules),
            links: await this.analyzeLinks(text, platform, platformModules),
            content: await this.analyzeContent(text, platform, platformModules),
            mentions: await this.analyzeMentions(text, platform, platformModules),
            emojis: await this.analyzeEmojis(text, platform, platformModules)
        };
        
        const signalSummary = this.buildSignalSummary(signals);
        const findings = this.generateFindings(signals);
        const { rawScore, confidence } = this.calculateOverallScore(signals);
        
        return {
            ...this.createResult({ rawScore, confidence, findings, processingTime: Date.now() - startTime }),
            modulesActive: platformModules.total,
            platform: platform,
            signals: signals,
            signalSummary: signalSummary
        };
    }
    
    // =========================================================================
    // 3-POINT INTELLIGENCE CORE
    // =========================================================================
    
    calculate3PointScore(predictiveScore, realtimeScore, historicalScore) {
        const predictive = { weight: 15, score: predictiveScore, contribution: Math.round((predictiveScore * 15) / 100 * 100) / 100, sources: [] };
        const realtime = { weight: 55, score: realtimeScore, contribution: Math.round((realtimeScore * 55) / 100 * 100) / 100, sources: [] };
        const historical = { weight: 30, score: historicalScore, contribution: Math.round((historicalScore * 30) / 100 * 100) / 100, sources: [] };
        const combinedScore = Math.round((predictive.contribution + realtime.contribution + historical.contribution) * 100) / 100;
        return { predictive, realtime, historical, combinedScore };
    }
    
    getConfidenceLevel(score, sourceCount) {
        const bonus = sourceCount >= 3 ? 15 : sourceCount >= 2 ? 5 : 0;
        const adjusted = Math.min(100, score + bonus);
        return { level: adjusted >= 70 ? 'high' : adjusted >= 40 ? 'medium' : 'low', score: adjusted, sources: sourceCount };
    }
    
    // Get Predictive score from WebAnalysisAgent
    async getPredictiveScore(signalType, items, platform) {
        if (items.length === 0) return { score: 0, sources: [] };
        const sources = [];
        let score = 0;
        
        try {
            const webAgent = window.AgentRegistry?.get('web-analysis');
            if (webAgent?.searchForFlaggedContent) {
                const queries = items.slice(0, 3).map(i => `${i} banned ${platform}`);
                const results = await webAgent.searchForFlaggedContent(queries, platform);
                if (results.available) {
                    score = results.riskScore || 0;
                    if (results.sources?.length) sources.push(`Web: ${results.sources.join(', ')}`);
                    if (results.recentMentions > 0) sources.push(`${results.recentMentions} discussions found`);
                    if (results.sentiment === 'negative') sources.push('Negative sentiment');
                }
            }
        } catch (e) { console.warn('Predictive error:', e); }
        
        return { score, sources };
    }
    
    // Get Real-Time score from PlatformAPIAgent
    async getRealtimeScore(signalType, items, platform) {
        if (items.length === 0) return { score: 0, sources: [], details: {} };
        const sources = [];
        let score = 0;
        let details = {};
        
        try {
            const apiAgent = window.AgentRegistry?.get('platform-api');
            
            if (signalType === 'hashtags' && apiAgent?.checkHashtagVisibility) {
                const results = await apiAgent.checkHashtagVisibility(items, platform);
                if (results.available) {
                    score = results.riskScore || 0;
                    details = { blocked: results.blocked, visible: results.visible };
                    if (results.blocked?.length) sources.push(`${results.blocked.length} blocked hashtag(s)`);
                    sources.push(`Visibility: ${results.visibility}`);
                }
            } else if (signalType === 'links' && apiAgent?.checkLinkVisibility) {
                const results = await apiAgent.checkLinkVisibility(items, platform);
                if (results.available) {
                    score = results.riskScore || 0;
                    details = { blocked: results.blocked, warned: results.warned };
                    if (results.warned?.length) sources.push(`${results.warned.length} link warning(s)`);
                }
            } else if (signalType === 'mentions' && apiAgent?.checkAccountStatus) {
                const results = await apiAgent.checkAccountStatus(items, platform);
                if (results.available) {
                    score = results.riskScore || 0;
                    details = { suspended: results.suspended, active: results.active };
                    if (results.suspended?.length) sources.push(`${results.suspended.length} suspended account(s)`);
                }
            }
        } catch (e) { console.warn('Realtime error:', e); }
        
        return { score, sources, details };
    }
    
    // Get Historical score from HistoricalAgent
    async getHistoricalScore(signalType, items, flaggedCount) {
        if (items.length === 0 && flaggedCount === 0) return { score: 0, sources: [] };
        const sources = [];
        let score = 0;
        
        try {
            const histAgent = window.AgentRegistry?.get('historical');
            if (histAgent?.getPastScores) {
                const results = await histAgent.getPastScores(items, signalType, this.currentPlatform);
                if (results.available) {
                    score = results.averageScore || 0;
                    if (results.itemsWithHistory > 0) sources.push(`${results.itemsWithHistory} in history`);
                    if (results.trendDirection === 'worsening') { sources.push('Trend: worsening'); score += 10; }
                }
            }
            if (flaggedCount > 0) {
                const flaggedScore = Math.min(100, flaggedCount * 25);
                score = Math.max(score, flaggedScore);
                sources.push(`${flaggedCount} flagged in DB`);
            }
        } catch (e) { console.warn('Historical error:', e); }
        
        return { score: Math.min(100, score), sources };
    }
    
    // =========================================================================
    // SIGNAL ANALYZERS
    // =========================================================================
    
    async analyzeHashtags(text, platform, mods) {
        const ts = new Date().toISOString();
        if (mods.hashtags === 0) return this.createDisabledSignal('hashtags', platform);
        
        const found = text.match(/#[\w\u0080-\uFFFF]+/g) || [];
        const bannedList = ['#followback', '#follow4follow', '#f4f', '#l4l', '#teamfollowback', '#gainwithxtina', '#500aday', '#like4like'];
        const banned = [], safe = [];
        
        for (const tag of found) {
            if (bannedList.includes(tag.toLowerCase())) {
                banned.push({ tag, reason: 'Engagement manipulation' });
            } else { safe.push(tag); }
        }
        
        // 3-Point Intelligence
        const pred = await this.getPredictiveScore('hashtags', found, platform);
        const rt = await this.getRealtimeScore('hashtags', found, platform);
        const hist = await this.getHistoricalScore('hashtags', found, banned.length);
        
        // Combine real-time local check with API check
        const localRealtimeScore = banned.length > 0 ? Math.min(100, banned.length * 35) : 0;
        const combinedRealtimeScore = Math.max(localRealtimeScore, rt.score);
        const realtimeSources = [...(rt.sources || [])];
        if (found.length) realtimeSources.push(`Found ${found.length} hashtag(s)`);
        if (banned.length) realtimeSources.push(`${banned.length} banned locally`);
        
        const tp = this.calculate3PointScore(pred.score, combinedRealtimeScore, hist.score);
        tp.predictive.sources = pred.sources;
        tp.realtime.sources = realtimeSources;
        tp.historical.sources = hist.sources;
        
        return {
            signalType: 'hashtags', moduleCount: mods.hashtags, enabled: true,
            threePoint: tp, combinedScore: tp.combinedScore,
            checked: found, flagged: { banned, restricted: [], monitored: [] }, safe,
            confidence: this.getConfidenceLevel(tp.combinedScore, [pred.score, combinedRealtimeScore, hist.score].filter(s => s > 0).length),
            lastVerified: ts
        };
    }
    
    async analyzeCashtags(text, platform, mods) {
        const ts = new Date().toISOString();
        if (mods.cashtags === 0) return this.createDisabledSignal('cashtags', platform);
        
        const found = text.match(/\$[A-Za-z]{1,5}/g) || [];
        const tp = this.calculate3PointScore(0, 0, 0);
        tp.realtime.sources = found.length ? [`Found ${found.length} cashtag(s)`] : ['No cashtags'];
        
        return {
            signalType: 'cashtags', moduleCount: mods.cashtags, enabled: true,
            threePoint: tp, combinedScore: 0,
            checked: found, flagged: { banned: [], restricted: [], monitored: [] }, safe: found,
            confidence: this.getConfidenceLevel(0, 1), lastVerified: ts
        };
    }
    
    async analyzeLinks(text, platform, mods) {
        const ts = new Date().toISOString();
        const found = text.match(/https?:\/\/[^\s]+/g) || [];
        
        const shorteners = ['bit.ly', 'tinyurl.com', 't.co', 'goo.gl', 'ow.ly', 'buff.ly'];
        const throttledDomains = { twitter: ['facebook.com', 'instagram.com', 'substack.com', 'threads.net', 'bsky.app'] };
        
        const shortenerHits = [], throttled = [], clean = [];
        let localScore = 0;
        const localSources = found.length ? [`Found ${found.length} URL(s)`] : ['No URLs'];
        
        for (const url of found) {
            const domain = this.extractDomain(url);
            let flagged = false;
            
            for (const s of shorteners) {
                if (domain.includes(s)) { shortenerHits.push({ url, domain: s, reason: 'Shortener reduces trust' }); localScore += 20; flagged = true; break; }
            }
            if (!flagged && platform === 'twitter') {
                for (const d of (throttledDomains[platform] || [])) {
                    if (domain.includes(d)) { throttled.push({ domain: d, delay: 2544, reason: 'Competitor - throttled' }); localScore += 25; localSources.push(`Throttled: ${d}`); flagged = true; break; }
                }
            }
            if (!flagged) clean.push(url);
        }
        if (shortenerHits.length) localSources.push('Link shortener detected');
        
        const pred = await this.getPredictiveScore('links', found, platform);
        const rt = await this.getRealtimeScore('links', found, platform);
        const hist = await this.getHistoricalScore('links', found, shortenerHits.length + throttled.length);
        
        const combinedRealtimeScore = Math.max(localScore, rt.score);
        const tp = this.calculate3PointScore(pred.score, combinedRealtimeScore, hist.score);
        tp.predictive.sources = pred.sources;
        tp.realtime.sources = [...localSources, ...(rt.sources || [])];
        tp.historical.sources = hist.sources;
        
        return {
            signalType: 'links', moduleCount: mods.links, enabled: true,
            threePoint: tp, combinedScore: tp.combinedScore,
            checked: found, flagged: { shorteners: shortenerHits, throttled, blocked: [] }, safe: clean,
            confidence: this.getConfidenceLevel(tp.combinedScore, [pred.score, combinedRealtimeScore, hist.score].filter(s => s > 0).length),
            lastVerified: ts
        };
    }
    
    async analyzeContent(text, platform, mods) {
        const ts = new Date().toISOString();
        let localScore = 0;
        const patterns = [];
        const sources = ['Content scan'];
        
        // Check excessive caps
        const capsRatio = text.length > 0 ? (text.match(/[A-Z]/g) || []).length / text.length : 0;
        if (capsRatio > 0.5 && text.length > 20) { patterns.push({ pattern: 'excessive_caps', ratio: capsRatio }); localScore += 10; sources.push('Excessive caps detected'); }
        
        // Check spam patterns
        if (/(?:free|win|giveaway).*(?:click|link|dm)/i.test(text)) { patterns.push({ pattern: 'spam_promotion' }); localScore += 25; sources.push('Spam pattern detected'); }
        if (/(?:like|share|comment|follow).*(?:if you|to win)/i.test(text)) { patterns.push({ pattern: 'engagement_bait' }); localScore += 20; sources.push('Engagement bait'); }
        
        const tp = this.calculate3PointScore(0, localScore, 0);
        tp.realtime.sources = sources;
        
        return {
            signalType: 'content', moduleCount: mods.content, enabled: true,
            threePoint: tp, combinedScore: tp.combinedScore,
            checked: [text.substring(0, 100) + (text.length > 100 ? '...' : '')],
            flagged: { banned: [], restricted: [], patterns },
            confidence: this.getConfidenceLevel(tp.combinedScore, 1), lastVerified: ts
        };
    }
    
    async analyzeMentions(text, platform, mods) {
        const ts = new Date().toISOString();
        const pattern = platform === 'reddit' ? /u\/[\w-]+/g : /@[\w]+/g;
        const found = text.match(pattern) || [];
        
        const pred = await this.getPredictiveScore('mentions', found, platform);
        const rt = await this.getRealtimeScore('mentions', found, platform);
        const hist = await this.getHistoricalScore('mentions', found, 0);
        
        const tp = this.calculate3PointScore(pred.score, rt.score, hist.score);
        tp.predictive.sources = pred.sources;
        tp.realtime.sources = found.length ? [`Found ${found.length} mention(s)`, ...(rt.sources || [])] : ['No mentions'];
        tp.historical.sources = hist.sources;
        
        return {
            signalType: 'mentions', moduleCount: mods.mentions, enabled: true,
            threePoint: tp, combinedScore: tp.combinedScore,
            checked: found, flagged: { suspended: rt.details?.suspended || [], shadowbanned: [], bots: [] }, safe: found,
            confidence: this.getConfidenceLevel(tp.combinedScore, [pred.score, rt.score, hist.score].filter(s => s > 0).length),
            lastVerified: ts
        };
    }
    
    async analyzeEmojis(text, platform, mods) {
        const ts = new Date().toISOString();
        const found = text.match(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]/gu) || [];
        let localScore = 0;
        const risky = [];
        const sources = found.length ? [`Found ${found.length} emoji(s)`] : ['No emojis'];
        
        // Crypto pump emojis
        const cryptoEmojis = ['üöÄ', 'üåô', 'üíé', 'üôå', 'üìà', 'üí∞', 'üî•'];
        for (const e of found) { if (cryptoEmojis.includes(e)) { risky.push(e); localScore += 5; } }
        if (risky.length > 0) sources.push(`${risky.length} crypto/hype emoji(s)`);
        if (found.length > 10) { localScore += 10; sources.push('Emoji spam'); }
        
        const tp = this.calculate3PointScore(0, localScore, 0);
        tp.realtime.sources = sources;
        
        return {
            signalType: 'emojis', moduleCount: mods.emojis, enabled: true,
            threePoint: tp, combinedScore: tp.combinedScore,
            checked: found, flagged: { risky, combinations: [] }, safe: found.filter(e => !risky.includes(e)),
            confidence: this.getConfidenceLevel(tp.combinedScore, 1), lastVerified: ts
        };
    }
    
    // =========================================================================
    // HELPERS
    // =========================================================================
    
    extractDomain(url) {
        try { return new URL(url).hostname.replace('www.', ''); }
        catch (e) { const m = url.match(/(?:https?:\/\/)?(?:www\.)?([^\/\?]+)/i); return m ? m[1] : url; }
    }
    
    createDisabledSignal(type, platform) {
        return {
            signalType: type, moduleCount: 0, enabled: false, note: `N/A for ${platform}`,
            threePoint: { predictive: { weight: 15, score: 0, contribution: 0, sources: [] }, realtime: { weight: 55, score: 0, contribution: 0, sources: [] }, historical: { weight: 30, score: 0, contribution: 0, sources: [] }, combinedScore: 0 },
            combinedScore: 0, checked: [], flagged: {}, safe: [], confidence: { level: 'n/a', score: 0, sources: 0 }
        };
    }
    
    buildSignalSummary(signals) {
        const scores = {};
        let active = 0, flagged = 0, scoreSum = 0, scoreCount = 0;
        for (const [type, sig] of Object.entries(signals)) {
            scores[type] = sig.combinedScore;
            if (sig.enabled) {
                active++;
                if (sig.combinedScore > 0) { scoreSum += sig.combinedScore; scoreCount++; }
                const fl = sig.flagged || {};
                if (Object.values(fl).some(arr => Array.isArray(arr) && arr.length > 0)) flagged++;
            }
        }
        return { totalSignals: 6, activeSignals: active, flaggedSignals: flagged, scores, averageScore: scoreCount > 0 ? Math.round((scoreSum / scoreCount) * 100) / 100 : 0 };
    }
    
    generateFindings(signals) {
        const findings = [];
        for (const [type, sig] of Object.entries(signals)) {
            if (!sig.enabled) continue;
            const fl = sig.flagged || {};
            if (fl.banned?.length) findings.push(this.createFinding(`banned_${type}`, `Banned ${type}: ${fl.banned.map(b => b.tag || b.url).join(', ')}`, 40));
            if (fl.shorteners?.length) findings.push(this.createFinding('link_shortener', `Link shortener: ${fl.shorteners.map(s => s.domain).join(', ')}`, 20));
            if (fl.throttled?.length) findings.push(this.createFinding('throttled_domain', `Throttled domain: ${fl.throttled.map(t => t.domain).join(', ')}`, 25));
            if (fl.patterns?.length) for (const p of fl.patterns) findings.push(this.createFinding(`pattern_${p.pattern}`, `Content pattern: ${p.pattern}`, 20));
            if (fl.risky?.length) findings.push(this.createFinding('risky_emojis', `Crypto/hype emojis: ${fl.risky.join(' ')}`, 10));
        }
        if (findings.length === 0) findings.push(this.createFinding('all_clear', 'All signals clear - no issues detected', 0));
        return findings;
    }
    
    calculateOverallScore(signals) {
        const weights = { hashtags: 25, cashtags: 10, links: 25, content: 20, mentions: 10, emojis: 10 };
        let weightedSum = 0, totalWeight = 0, confSum = 0, confCount = 0;
        for (const [type, sig] of Object.entries(signals)) {
            if (!sig.enabled) continue;
            const w = weights[type] || 10;
            weightedSum += sig.combinedScore * w;
            totalWeight += w;
            if (sig.confidence?.score) { confSum += sig.confidence.score; confCount++; }
        }
        return { rawScore: totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0, confidence: confCount > 0 ? Math.round(confSum / confCount) : 50 };
    }
}

const agent = new DetectionAgent();
window.AgentRegistry.register(agent);
window.DetectionAgent = agent;
window.PLATFORM_MODULES = PLATFORM_MODULES;
console.log('‚úÖ DetectionAgent (Factor 4) loaded - Full 3-Point Intelligence');
})();
</script>

<!-- ============================================================================
     AGENT-PREDICTIVE.JS - Factor 5 (20%) - Predictive analysis
     ============================================================================ -->
<script>
(function() {
'use strict';

class PredictiveAgent extends window.AgentBase {
    constructor() {
        super('predictive', 5, 20);
        
        this.sensitiveTopics = [
            { pattern: /election|vote|ballot|poll/i, risk: 40, category: 'political' },
            { pattern: /covid|vaccine|pandemic|virus/i, risk: 35, category: 'health' },
            { pattern: /crypto|bitcoin|nft|token|coin/i, risk: 25, category: 'financial' },
            { pattern: /war|invasion|conflict|military/i, risk: 35, category: 'geopolitical' },
            { pattern: /giveaway|free|winner|claim/i, risk: 30, category: 'spam' }
        ];
    }
    
    async analyze(input) {
        const startTime = Date.now();
        const findings = [];
        const flags = [];
        let rawScore = 0;
        
        const text = input.text || input.postData?.text || '';
        const platform = input.platform || 'twitter';
        
        // Check sensitive topics
        for (const topic of this.sensitiveTopics) {
            if (topic.pattern.test(text)) {
                findings.push(this.createFinding('sensitive_topic', `Content touches sensitive topic: ${topic.category}`, topic.risk, { category: topic.category }));
                rawScore += topic.risk * 0.4;
                flags.push(`sensitive_${topic.category}`);
            }
        }
        
        // Check spam patterns
        if (/(?:free|win|giveaway).*(?:click|link|dm)/i.test(text)) {
            findings.push(this.createFinding('spam_pattern', 'Content matches spam patterns', 30));
            rawScore += 25;
        }
        
        // Check engagement bait
        if (/(?:like|share|comment|follow).*(?:if you|to win)/i.test(text)) {
            findings.push(this.createFinding('engagement_bait', 'Engagement bait detected', 25));
            rawScore += 20;
        }
        
        // Check urgency tactics
        if (/(?:act now|limited time|hurry|last chance|don't miss)/i.test(text)) {
            findings.push(this.createFinding('urgency_tactics', 'Urgency tactics common in spam', 15));
            rawScore += 12;
        }
        
        // Excessive caps
        const capsRatio = text.length > 0 ? (text.match(/[A-Z]/g) || []).length / text.length : 0;
        if (capsRatio > 0.5 && text.length > 20) {
            findings.push(this.createFinding('excessive_caps', `Excessive capitalization (${(capsRatio * 100).toFixed(0)}%)`, 10));
            rawScore += 8;
        }
        
        if (findings.length === 0) {
            findings.push(this.createFinding('clean_prediction', 'No predictive risk factors found', 0));
        }
        
        return this.createResult({ rawScore: Math.min(100, rawScore), confidence: 70, findings, flags, processingTime: Date.now() - startTime });
    }
}

const agent = new PredictiveAgent();
window.AgentRegistry.register(agent);
window.PredictiveAgent = agent;
console.log('‚úÖ PredictiveAgent (Factor 5) loaded');
})();
</script>

<!-- ============================================================================
     5-FACTOR ENGINE - Orchestrator
     ============================================================================ -->
<script>
(function() {
'use strict';

class FiveFactorEngine {
    constructor() {
        this.version = '2.0.0';
        this.useDemo = true;
    }
    
    async powerCheck(input) {
        const startTime = Date.now();
        const platform = input.platform || 'twitter';
        
        // Run all registered agents
        const agentResults = await window.AgentRegistry.runAll(input);
        
        // Synthesize results
        const synthesis = this.synthesize(agentResults);
        
        // Get Detection Agent's detailed output
        const detectionResult = agentResults.find(r => r.factorNumber === 4);
        
        return {
            checkType: 'powerCheck',
            platform,
            timestamp: new Date().toISOString(),
            processingTime: Date.now() - startTime,
            demo: this.useDemo,
            agents: agentResults.map(r => this.formatAgent(r)),
            synthesis: {
                probability: synthesis.probability,
                reachScore: 100 - synthesis.probability,
                confidence: { level: synthesis.confidence >= 70 ? 'high' : synthesis.confidence >= 40 ? 'medium' : 'low', score: synthesis.confidence, sources: agentResults.length },
                verdict: synthesis.verdict,
                primaryIssues: synthesis.issues
            },
            detectionDetails: detectionResult ? { signals: detectionResult.signals, signalSummary: detectionResult.signalSummary } : null,
            recommendations: this.generateRecs(synthesis, agentResults)
        };
    }
    
    synthesize(results) {
        let weightedTotal = 0, weightSum = 0, confSum = 0, confCount = 0;
        const issues = [];
        
        for (const r of results) {
            const w = r.weight || 20;
            weightedTotal += (r.rawScore || 0) * w;
            weightSum += w;
            if (r.confidence) { confSum += r.confidence; confCount++; }
            for (const f of (r.findings || [])) {
                if (f.severity === 'critical' || f.severity === 'high' || f.impact >= 25) {
                    issues.push({ message: f.message, severity: f.severity, agent: f.agent });
                }
            }
        }
        
        const probability = weightSum > 0 ? Math.round(weightedTotal / weightSum) : 0;
        const confidence = confCount > 0 ? Math.round(confSum / confCount) : 50;
        const verdict = probability <= 15 ? 'CLEAR' : probability <= 30 ? 'LIKELY CLEAR' : probability <= 50 ? 'UNCERTAIN' : probability <= 70 ? 'LIKELY RESTRICTED' : 'RESTRICTED';
        
        return { probability, confidence, verdict, issues: issues.slice(0, 10) };
    }
    
    formatAgent(r) {
        const out = { agent: r.agent || r.factorName, agentId: r.agentId, factor: r.factorNumber, weight: r.weight, status: r.error ? 'error' : 'complete', rawScore: r.rawScore || 0, weightedScore: r.weightedScore || 0, confidence: r.confidence || 0, findings: r.findings || [], flags: r.flags || [] };
        if (r.factorNumber === 4) { out.modulesActive = r.modulesActive; out.signals = r.signals; out.signalSummary = r.signalSummary; }
        return out;
    }
    
    generateRecs(synthesis, results) {
        const recs = [];
        const det = results.find(r => r.factorNumber === 4);
        
        if (det?.signals) {
            const sig = det.signals;
            if (sig.hashtags?.flagged?.banned?.length) recs.push({ priority: 'critical', action: `Remove banned hashtags: ${sig.hashtags.flagged.banned.map(h => h.tag).join(', ')}`, impact: 'High - these hashtags trigger immediate filtering' });
            if (sig.links?.flagged?.shorteners?.length) recs.push({ priority: 'high', action: 'Replace link shorteners with full URLs', impact: 'Medium - shorteners reduce trust score' });
            if (sig.links?.flagged?.throttled?.length) recs.push({ priority: 'medium', action: `Avoid competitor domains: ${sig.links.flagged.throttled.map(t => t.domain).join(', ')}`, impact: 'Medium - these links are delayed/throttled' });
            if (sig.content?.flagged?.patterns?.length) recs.push({ priority: 'high', action: 'Rewrite content to avoid spam patterns', impact: 'High - spam patterns trigger filters' });
            if (sig.emojis?.flagged?.risky?.length > 2) recs.push({ priority: 'low', action: 'Reduce crypto/hype emojis', impact: 'Low - may trigger financial content filters' });
        }
        
        if (recs.length === 0) {
            recs.push({ priority: 'info', action: synthesis.probability < 30 ? 'Content looks good! No major issues detected.' : 'Review flagged items above for specific recommendations', impact: 'N/A' });
        }
        
        return recs;
    }
}

const engine = new FiveFactorEngine();
window.shadowBanEngine = engine;
window.FiveFactorEngine = FiveFactorEngine;
console.log('‚úÖ 5-Factor Engine v2.0 loaded');
})();
</script>

<!-- ============================================================================
     UI FUNCTIONS
     ============================================================================ -->
<script>
function updateAgentStatus() {
    const container = document.getElementById('agent-status');
    const agents = window.AgentRegistry.getAll();
    const factorNames = { 1: 'Platform API', 2: 'Web Analysis', 3: 'Historical', 4: 'Detection', 5: 'Predictive' };
    
    let html = '';
    for (let i = 1; i <= 5; i++) {
        const agent = Object.values(agents).find(a => a.factorNumber === i);
        html += `<div class="agent-card ${agent ? 'loaded' : 'missing'}">
            <strong>Factor ${i}: ${factorNames[i]}</strong><br>
            <small>Weight: ${agent?.weight || 0}%</small><br>
            <span class="${agent ? 'pass' : 'fail'}">${agent ? '‚úÖ Ready' : '‚ùå Missing'}</span>
        </div>`;
    }
    
    const total = Object.keys(agents).length;
    const totalWeight = Object.values(agents).reduce((s, a) => s + a.weight, 0);
    html += `<div class="agent-card ${total === 5 ? 'loaded' : 'missing'}">
        <strong>Total</strong><br>
        <small>${total}/5 agents | ${totalWeight}% weight</small><br>
        <span class="${total === 5 ? 'pass' : 'warn'}">${total === 5 ? '‚úÖ All loaded' : '‚ö†Ô∏è Incomplete'}</span>
    </div>`;
    
    container.innerHTML = html;
}

async function runDetectionOnly() {
    const content = document.getElementById('test-content').value;
    const platform = document.getElementById('platform-select').value;
    const resultDiv = document.getElementById('main-result');
    const signalDiv = document.getElementById('signal-results');
    
    resultDiv.innerHTML = '<p class="info">üîÑ Running Detection Agent only...</p>';
    
    try {
        const det = window.AgentRegistry.get('detection');
        const result = await det.analyze({ text: content, platform, type: 'text' });
        
        resultDiv.innerHTML = `<h3>Detection Agent Result</h3>
            <p>Score: <strong class="${result.rawScore > 50 ? 'fail' : result.rawScore > 25 ? 'warn' : 'pass'}">${result.rawScore}%</strong> | Confidence: ${result.confidence}%</p>
            <p>Processing: ${result.processingTime}ms | Modules: ${result.modulesActive}</p>`;
        
        renderSignals(result.signals, signalDiv);
        document.getElementById('raw-output').textContent = JSON.stringify(result, null, 2);
        document.getElementById('all-agents').innerHTML = '';
        
    } catch (e) {
        resultDiv.innerHTML = `<p class="fail">‚ùå Error: ${e.message}</p>`;
    }
}

async function runFullAnalysis() {
    const content = document.getElementById('test-content').value;
    const platform = document.getElementById('platform-select').value;
    const resultDiv = document.getElementById('main-result');
    const signalDiv = document.getElementById('signal-results');
    const agentDiv = document.getElementById('all-agents');
    
    resultDiv.innerHTML = '<p class="info">üîÑ Running full 5-Factor analysis...</p>';
    
    try {
        const result = await window.shadowBanEngine.powerCheck({ text: content, platform, type: 'text' });
        
        // Main result
        const scoreClass = result.synthesis.probability > 50 ? 'score-high' : result.synthesis.probability > 25 ? 'score-medium' : 'score-low';
        resultDiv.innerHTML = `
            <div class="score-display ${scoreClass}">
                ${result.synthesis.probability}% Risk
            </div>
            <h3>Verdict: ${result.synthesis.verdict}</h3>
            <p>Reach Score: ${result.synthesis.reachScore}% | Confidence: ${result.synthesis.confidence.score}% (${result.synthesis.confidence.level})</p>
            <p>Platform: ${result.platform} | Processing: ${result.processingTime}ms</p>
            
            <h3>üéØ Recommendations</h3>
            <ul class="findings-list">
                ${result.recommendations.map(r => `<li class="${r.priority === 'critical' ? 'critical' : r.priority === 'high' ? 'high' : r.priority === 'medium' ? 'medium' : 'low'}">
                    <strong>[${r.priority.toUpperCase()}]</strong> ${r.action}
                    ${r.impact ? `<br><small style="color:#888;">Impact: ${r.impact}</small>` : ''}
                </li>`).join('')}
            </ul>
            
            ${result.synthesis.primaryIssues.length > 0 ? `
            <h3>‚ö†Ô∏è Primary Issues</h3>
            <ul class="findings-list">
                ${result.synthesis.primaryIssues.map(i => `<li class="${i.severity}">${i.message}</li>`).join('')}
            </ul>` : ''}
        `;
        
        // Signal cards
        if (result.detectionDetails?.signals) {
            renderSignals(result.detectionDetails.signals, signalDiv);
        }
        
        // All agent results
        let agentHtml = '';
        for (const agent of result.agents) {
            agentHtml += `
                <div style="background:#252525;padding:15px;border-radius:6px;margin:10px 0;border-left:3px solid ${agent.rawScore > 50 ? '#dc2626' : agent.rawScore > 25 ? '#fbbf24' : '#4ade80'};">
                    <strong>Factor ${agent.factor}: ${agent.agent}</strong> (${agent.weight}%)
                    <span style="float:right;font-size:20px;" class="${agent.rawScore > 50 ? 'fail' : agent.rawScore > 25 ? 'warn' : 'pass'}">${agent.rawScore}%</span>
                    <br><small>Confidence: ${agent.confidence}% | Status: ${agent.status}</small>
                    ${agent.findings.length > 0 ? `
                    <ul class="findings-list" style="margin-top:10px;">
                        ${agent.findings.slice(0, 5).map(f => `<li class="${f.severity}">${f.message}</li>`).join('')}
                    </ul>` : ''}
                </div>
            `;
        }
        agentDiv.innerHTML = agentHtml;
        
        document.getElementById('raw-output').textContent = JSON.stringify(result, null, 2);
        
    } catch (e) {
        resultDiv.innerHTML = `<p class="fail">‚ùå Error: ${e.message}</p><pre>${e.stack}</pre>`;
    }
}

function renderSignals(signals, container) {
    if (!signals) { container.innerHTML = '<p class="warn">No signal data</p>'; return; }
    
    let html = '';
    for (const [type, sig] of Object.entries(signals)) {
        if (!sig.enabled) {
            html += `<div class="signal-card" style="opacity:0.5;"><h4>${type.toUpperCase()}</h4><p>Disabled for this platform</p></div>`;
            continue;
        }
        
        const tp = sig.threePoint;
        html += `
            <div class="signal-card">
                <h4>${type.toUpperCase()} <span style="float:right;color:${sig.combinedScore > 50 ? '#f87171' : sig.combinedScore > 20 ? '#fbbf24' : '#4ade80'};">${sig.combinedScore}</span></h4>
                <p style="font-size:12px;color:#888;">Modules: ${sig.moduleCount} | Checked: ${sig.checked?.length || 0} | Confidence: ${sig.confidence?.level || 'n/a'}</p>
                
                <div class="three-point">
                    <div>
                        <div class="label">PREDICTIVE (15%)</div>
                        <strong>${tp.predictive.score}</strong> ‚Üí ${tp.predictive.contribution}
                        <div style="font-size:9px;color:#666;margin-top:3px;">${tp.predictive.sources?.slice(0, 2).join(', ') || 'No data'}</div>
                    </div>
                    <div>
                        <div class="label">REAL-TIME (55%)</div>
                        <strong>${tp.realtime.score}</strong> ‚Üí ${tp.realtime.contribution}
                        <div style="font-size:9px;color:#666;margin-top:3px;">${tp.realtime.sources?.slice(0, 2).join(', ') || 'No data'}</div>
                    </div>
                    <div>
                        <div class="label">HISTORICAL (30%)</div>
                        <strong>${tp.historical.score}</strong> ‚Üí ${tp.historical.contribution}
                        <div style="font-size:9px;color:#666;margin-top:3px;">${tp.historical.sources?.slice(0, 2).join(', ') || 'No data'}</div>
                    </div>
                </div>
                
                ${renderFlagged(sig.flagged)}
            </div>
        `;
    }
    container.innerHTML = html;
}

function renderFlagged(flagged) {
    if (!flagged) return '';
    const items = [];
    for (const [key, arr] of Object.entries(flagged)) {
        if (Array.isArray(arr) && arr.length > 0) {
            items.push(`<span style="color:#f87171;">${key}: ${arr.length}</span>`);
        }
    }
    return items.length ? `<p style="font-size:11px;margin-top:8px;">Flagged: ${items.join(' | ')}</p>` : '';
}

window.onload = function() { setTimeout(updateAgentStatus, 100); };
</script>

</body>
</html>
